/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define BASE               0x40010800
#define GPIOA_CRH         *(volatile uint32_t *)(BASE + 0x04)
#define GPIOA_ODR         *(volatile uint32_t *)(BASE + 0x0C)
#define GPIOA_CRL         *(volatile uint32_t *)(BASE + 0x0)
#define GPIOA_IDR         *(volatile uint32_t *)(BASE + 0x08)

#define GPIOB_BASE         0x40010C00
#define GPIOB_CRH         *(volatile uint32_t *)(GPIOB_BASE + 0x04)
#define GPIOB_ODR         *(volatile uint32_t *)(GPIOB_BASE + 0x0C)
#define GPIOB_CRL         *(volatile uint32_t *)(GPIOB_BASE + 0x0)
#define GPIOB_IDR         *(volatile uint32_t *)(GPIOB_BASE + 0x08)


#define RCC_BASE            0x40021000
#define RCC_CR             *(volatile uint32_t *)(RCC_BASE + 0x00)
#define RCC_APBENB         *(volatile uint32_t *)(RCC_BASE + 0x18)
#define RCC_CFGR           *(volatile uint32_t *)(RCC_BASE + 0x04)


/******************************************************************/
void Init_RCC(void)
{
	//clock configuration
	RCC_CR |= 1<<0;
	// system clock HSI 00 at bits 1:0
	RCC_CFGR |= (0b00<<0);
	// set APB No pre scaler
	RCC_CFGR |= (0b0000<<4);
	// set APB1 divided by 2
	RCC_CFGR |= (0b100<<8);
	// set APB1 divided by 4
	RCC_CFGR |= (0b101<<11);

	//Enable clock for PORTA
	RCC_APBENB |= 1<<2;
	// Enable clock for PORTB
	RCC_APBENB |= 1<<3;
}

void Init_GPIO(void)
{
	// configure GPIOA pin 13 as input floating, MODE[1:0]=00, CNFy[1:0]=01
	GPIOA_CRH  &= 0xff0fffff;
	GPIOA_CRH  |= (0b0100<<20);

	// configure GPIOA pin 1 as input floating, MODE[1:0]=00, CNFy[1:0]=01
	GPIOA_CRL  &= 0xffffff0f;
	GPIOA_CRL  |= (0b0100<<4);

	// configure GPIOB pin 13 as output push_pull
	GPIOB_CRH &= 0xff0fffff;
	GPIOB_CRH |= (0b0001<<20);
    //Note output open drain also valid  (GPIOB_CRH |= (0b0101<<20))

	// configure GPIOB pin 1 as output push_pull
	GPIOB_CRL &= 0xffffff0f;
	GPIOB_CRL |= (0b0001<<4);
	//Note output open drain also valid  (GPIOB_CRL |= (0b0001<<4))



}

void pseudo_delay(int s){

	for(int i=0; i<s; i++);

}


int main(void)
{
	Init_RCC();
    Init_GPIO();


	while(1){

         // single pressing
		if((GPIOA_IDR & (1<<1))>>1 == 0){

			GPIOB_ODR ^= 1<<1;
			while(((GPIOA_IDR & (1<<1))>>1 == 0));

		}

		if((GPIOA_IDR & (1<<13))>>13 == 1){

			GPIOB_ODR ^= 1<<13;

		}

		pseudo_delay(1000);

	}
}

